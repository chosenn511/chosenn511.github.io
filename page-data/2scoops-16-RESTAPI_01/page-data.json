{"componentChunkName":"component---src-templates-post-tsx","path":"/2scoops-16-RESTAPI_01/","result":{"data":{"markdownRemark":{"html":"<p><code class=\"language-text\">REST API</code>(Representational State Transfer)는 기존의 HTTP 통신 프로토콜을 제대로 활용하기 위해 만들어진 규칙이다. 또한 인터넷은 더이상 <code class=\"language-text\">HTML</code>형식에만 국한되지 않고 <code class=\"language-text\">Ajax</code>, <code class=\"language-text\">JSON</code>, <code class=\"language-text\">XML</code>, <code class=\"language-text\">YAML</code>등의 여러 형식을 지원하고 있다. 이에 따라 다양한 환경과 용도에 맞는 데이터를 제공하는 디자인으로 <code class=\"language-text\">REST API</code>를 사용하는 경우가 많아졌다. 이번 포스트에서는 REST API의 개념을 숙지하고 장고에서 REST API를 구현하는 방법들에 대해 정리해보자.</p>\n<p>해당 포스트는 <code class=\"language-text\">Two Scoops of Django</code>의 16장 <code class=\"language-text\">REST API 구현하기</code>를 요약하여 작성하였다.  </p>\n<br>\n<h3 id=\"restful하다\" style=\"position:relative;\"><a href=\"#restful%ED%95%98%EB%8B%A4\" aria-label=\"restful하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RESTful하다?</h3>\n<ul>\n<li>모든 자원에는 <code class=\"language-text\">ID</code>가 부여되며 ID를 통해 서로 구별된다.</li>\n<li>모든 자원은 연결될 수 있다.</li>\n<li>HTTP 및 대부분의 소프트웨어가 가지는 기본적인 데이터 처리기능인 표준 통신메서드를 사용한다.(<code class=\"language-text\">Create-POST(생성)</code>, <code class=\"language-text\">Retrieve-GET(조회)</code>, <code class=\"language-text\">Update-PUT(수정)</code>, <code class=\"language-text\">Delete-DELETE(삭제)</code>)</li>\n</ul>\n<br>\n<h3 id=\"패키지-api를-제작하기-위한-패키지들\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%ED%82%A4%EC%A7%80-api%EB%A5%BC-%EC%A0%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%93%A4\" aria-label=\"패키지 api를 제작하기 위한 패키지들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패키지 API를 제작하기 위한 패키지들</h3>\n<p>(장고 기준)</p>\n<h4 id=\"code-classlanguage-textdjango-rest-frameworkcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textdjango-rest-frameworkcode\" aria-label=\"code classlanguage textdjango rest frameworkcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">django-rest-framework</code></h4>\n<p>프로젝트시 사용했던 패키지로, 장고의 클래스 기반 뷰를 바탕으로 브라우징이 가능한 편리한 API 기능을 제공한다. 현존하는 패키지 중에서는 클래스 기반 뷰와 함수 기반 뷰를 모두 제공하기 때문에 가장 많이 사용된다.</p>\n<br>\n<h4 id=\"code-classlanguage-textdjango-tastypiecode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textdjango-tastypiecode\" aria-label=\"code classlanguage textdjango tastypiecode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">django-tastypie</code></h4>\n<p><a href=\"https://django-tastypie.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">링크</a></p>\n<p><code class=\"language-text\">django-tastypie</code>를 사용하면 자체적으로 제공하는 클래스 기반 뷰 시스템으로 장고에서 API를 제작할 수 있다.</p>\n<br>\n<h4 id=\"code-classlanguage-textdjango-bracescode-code-classlanguage-textdjango-jsonviewcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textdjango-bracescode-code-classlanguage-textdjango-jsonviewcode\" aria-label=\"code classlanguage textdjango bracescode code classlanguage textdjango jsonviewcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">django-braces</code>, <code class=\"language-text\">django-jsonview</code></h4>\n<p>단순하게 API를 제작하고 싶을 경우에는 <code class=\"language-text\">django-braces</code>나 <code class=\"language-text\">django-jsonview</code>를 사용할 수 있다.</p>\n<p><a href=\"https://django-braces.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">django-braces</a>는 클래스 기반 뷰를 제공하며 다양한 기능의 Mixin을 제공하고 있다. 현재 장고에는 자주쓰는 <code class=\"language-text\">LoginRequiredMixin</code>과 같은 기능은 내장되어 있다.</p>\n<p><a href=\"https://github.com/jsocol/django-jsonview\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">django-jsonview</a>는 파이썬 객체를 JSON 형태로 변환해주는 간단한 데코레이터를 제공한다.</p>\n<br>\n<h3 id=\"http-메서드\" style=\"position:relative;\"><a href=\"#http-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"http 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 메서드</h3>\n<p>REST API는 앞서 말한 것 처럼 HTTP 프로토콜을 제대로 활용하기 위해 만들어진 규칙이다. HTTP는 콘텐트를 배포하기 위한 액션을 정의한 메서드 집합을 제공하는데, REST API 구현시 반드시 이러한 메서드들에 대한 개념을 알고 사용하여야 한다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">HTTP 메서드</th>\n<th align=\"center\">요청 목적</th>\n<th align=\"center\">비슷한 개념의 SQL 명령어</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">POST</td>\n<td align=\"center\">새로운 리소스 <code class=\"language-text\">생성</code></td>\n<td align=\"center\">INSERT</td>\n</tr>\n<tr>\n<td align=\"center\">GET</td>\n<td align=\"center\">리소스 읽기</td>\n<td align=\"center\">SELECT</td>\n</tr>\n<tr>\n<td align=\"center\">HEAD</td>\n<td align=\"center\">리소스의 메타데이터 요청</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">PUT</td>\n<td align=\"center\">리소스 수정(업데이트)</td>\n<td align=\"center\">UPDATE</td>\n</tr>\n<tr>\n<td align=\"center\">PATCH</td>\n<td align=\"center\">리소스 부분 수정</td>\n<td align=\"center\">UPDATE</td>\n</tr>\n<tr>\n<td align=\"center\">DELETE</td>\n<td align=\"center\">리소스 삭제</td>\n<td align=\"center\">DELETE</td>\n</tr>\n<tr>\n<td align=\"center\">OPTIONS</td>\n<td align=\"center\">현재 웹서버에서 지원하는 method가 어떤 것들이 있는지 출력</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">TRACE</td>\n<td align=\"center\">요청에 대한 반환 에코(다시 알려줌), 디버깅시 유용하게 사용가능</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">CONNECT</td>\n<td align=\"center\">TCP/IP 터널링(일반적으로 구현x)</td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<br>\n<h4 id=\"code-classlanguage-text메타데이터code\" style=\"position:relative;\"><a href=\"#code-classlanguage-text%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0code\" aria-label=\"code classlanguage text메타데이터code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">메타데이터?</code></h4>\n<p>메타(Meta)는 일반적으로 <code class=\"language-text\">~에 관한</code>이라는 의미를 지니고 있다. 따라서 메타데이터는 다른 데이터를 기술하기 위해 사용하는 데이터라고 할 수 있다. 요약하면 '데이터에 관한 구조화된 데이터로, 다른 데이터를 설명해주는 데이터라 할 수 있다.</p>\n<p><code class=\"language-text\">HEAD</code> 메서드를 사용하면 전체 표현을 읽지 않고도 <code class=\"language-text\">메타데이터</code>를 통해 리소스의 정보를 파악할 수 있다. 클라이언트는 <code class=\"language-text\">OPTIONS</code> 또한 사용하는데, 해당 메서드를 통해 특정 리소스에 허가된 메서드를 검사할 수 있다.</p>\n<br>\n<h4 id=\"code-classlanguage-textconnectcode와-터널링\" style=\"position:relative;\"><a href=\"#code-classlanguage-textconnectcode%EC%99%80-%ED%84%B0%EB%84%90%EB%A7%81\" aria-label=\"code classlanguage textconnectcode와 터널링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">CONNECT</code>와 터널링</h4>\n<p>http 요청 메서드 중 <code class=\"language-text\">CONNECT</code>는 생소해서 좀 더 찾아보았다. 먼저 설명에 필요한 <code class=\"language-text\">프록시</code>나 <code class=\"language-text\">터널</code> 등에 대한 개념을 정리하면 다음과 같다. <code class=\"language-text\">프록시</code>는 서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램이다. 클라이언트로부터 요청을 서버에 전송하고 서버로부터 받은 응답을 클라이언트에 전송한다.</p>\n<p>이러한 프록시 서버 중 일부는 터널을 구성한다. <code class=\"language-text\">터널</code>은 서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하면서 접속을 유지해주는 중계 프로그램이다. 터널은 요청에 따라서 다른 서버와의 통신 경로를 만들기도 하는데, 클라이언트가 인증(SSL, HTTPS)을 사용하여 서버와 안전하게 통신하려고 할 경우에도 사용한다.</p>\n<br>\n<h4 id=\"http-요청메서드와-rest-api\" style=\"position:relative;\"><a href=\"#http-%EC%9A%94%EC%B2%AD%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-rest-api\" aria-label=\"http 요청메서드와 rest api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 요청메서드와 REST API</h4>\n<ul>\n<li>읽기 전용 API만 구현할 경우에는 <code class=\"language-text\">GET</code>을 사용한다.</li>\n<li>읽기/쓰기 API를 구현할 경우에는 <code class=\"language-text\">POST</code>, <code class=\"language-text\">PUT</code>, <code class=\"language-text\">DELETE</code> 등을 사용할 수 있다. <code class=\"language-text\">PUT</code>을 사용해도 <code class=\"language-text\">POST</code>와 같이 리소스를 생성할 수도 있다. 구현하기 나름이다.</li>\n<li>반대로 단순하게 작성하려면 모든 API의 통신 메서드를 <code class=\"language-text\">GET</code>과 <code class=\"language-text\">POST</code>만으로 구현할 수도 있다.</li>\n<li><strong><code class=\"language-text\">GET</code>, <code class=\"language-text\">PUT</code>,<code class=\"language-text\">DELETE</code>는 여러 번 실행해도 그 결과가 변하지 않는 <code class=\"language-text\">멱등(idempotent)</code> 관계이다.</strong></li>\n<li><strong><code class=\"language-text\">POST</code>, <code class=\"language-text\">PATCH</code>는 여러 번 실행할 때마다 변한다.</strong></li>\n<li><code class=\"language-text\">PUT</code>을 구현했다면 <code class=\"language-text\">PATCH</code>도 구현하는 것이 좋다.</li>\n</ul>\n<br>\n<h4 id=\"http-메서드와-멱등-관계\" style=\"position:relative;\"><a href=\"#http-%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-%EB%A9%B1%EB%93%B1-%EA%B4%80%EA%B3%84\" aria-label=\"http 메서드와 멱등 관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 메서드와 멱등 관계</h4>\n<p><code class=\"language-text\">멱등성</code>(idempotence)이란 수학이나 전산학에서 연산을 여러 번 반복 적용해도 결과가 달라지지 않는 성질을 의미한다. 예를 들어 4를 계속 곱해도 같은 값이 나오게 하려면 0을 계속 곱하거나 1을 곱하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">4 * 1 * 1 * ... * 1 = 4    # 언제나 4\n4 * 0 * 0 * ... * 0 = 0    # 언제나 0</code></pre></div>\n<p>이처럼 HTTP 메서드에서도 여러 번 같은 요청을 보냈을 때 같은 결과를 보내주는 메서드들이 있다. <code class=\"language-text\">GET</code>, <code class=\"language-text\">PUT</code>, <code class=\"language-text\">HEAD</code>, <code class=\"language-text\">DELETE</code> 등이 바로 <code class=\"language-text\">멱등성</code>을 띤다. 즉, <strong>HTTP 메서드에서 멱등성은 동일한 요청에서 동일한 결과를 보장함</strong>을 의미한다. 즉, 자체 <code class=\"language-text\">context</code>가 없으면 멱등성이 성립한다.</p>\n<p>먼저, <code class=\"language-text\">GET</code>과 <code class=\"language-text\">HEAD</code>요청은 데이터를 읽기만 하고 서버의 상태를 바꾸지 않는다. readonly의 성격을 가지기 때문에 당연히 context가 필요 없다. 그렇다면 <code class=\"language-text\">PUT</code>은 왜 멱등성을 충족할까? <code class=\"language-text\">PUT</code>은 RESTful 관례상으로 <code class=\"language-text\">replace</code>를 의미하기 때문에 context를 가질 필요가 없다. 만약 개인정보를 수정해야한다면 원래의 개인정보는 사용자가 입력한 새로운 정보로 대체된다. <code class=\"language-text\">PUT</code>요청 시 항목 X를 B로 '간주'하게 되는 것이다.</p>\n<p><code class=\"language-text\">POST</code>나 <code class=\"language-text\">PATCH</code>의 경우에는 RESTful 관례상 자체적으로 요청을 처리하는 함수가 자체 <code class=\"language-text\">context</code>를 가지기 때문에 매 요청마다 다른 결과가 나올 수 있다. 특히 <code class=\"language-text\">PATCH</code>는 RESTful 관례상 <code class=\"language-text\">update</code>를 의미하기 때문에 context를 가진다. <code class=\"language-text\">PUT</code>과는 달리 항목 X를 A에서 B로 변경하는 것이기 때문에 A의 값에 따라 결과가 달라질 수 있다.</p>\n<p><code class=\"language-text\">DELETE</code>를 쓸 때는 한번 요청을 보내면 해당 URL의 리소스가 삭제된다. 그리고 다음에 같은 요청을 보내도 이미 지워진 내용을 또 지운 것이므로 결과가 같다. 따라서 멱등법칙이 성립하는 것이다.</p>\n<p><strong>멱등성은 설계에 따라 성립하지 않을 수도 있다.</strong> 당연한 말이지만 위에서 설명한 HTTP 메서드들의 멱등성은 서버 개발자가 어떻게 구현하고 설계하느냐에 따라 성립하지 않을 수도 있다. 장고에서는 자동으로 관례를 따르기 때문에 알아두는 것이 좋다.</p>\n<p>정리하면 HTTP의 멱등성은 동일한 요청(input)을 입력할 때 동일한 결과(output)가 나오는 것을 의미한다. <strong>이러한 멱등성은 HTTP 통신의 신뢰성을 높여준다.</strong> 여러 번 요청 후에도 같은 결과가 보장될 경우 요청이 실패했다고 해도 단순히 같은 요청을 다시 보내면 되기 때문이다. 이미 먼저 보낸 요청이 처리되었을 경우에도 같은 결과이므로 상관없다. 그렇다면 멱등관계가 성립되지 않는 <code class=\"language-text\">POST</code>, <code class=\"language-text\">PATCH</code>와 같은 메서드는 어떨까? 당연히 안전하지 않다.</p>\n<br>\n<h3 id=\"http-상태코드\" style=\"position:relative;\"><a href=\"#http-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C\" aria-label=\"http 상태코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 상태코드</h3>\n<p>기본적이고 자주 쓰이는 상태코드는 <a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">다음 링크</a>를 참고하면 된다. 해당 포스트에서는 상태코드 중 기억하면 좋을 것만 정리해 보았다.</p>\n<h4 id=\"범위별-응답코드-의미\" style=\"position:relative;\"><a href=\"#%EB%B2%94%EC%9C%84%EB%B3%84-%EC%9D%91%EB%8B%B5%EC%BD%94%EB%93%9C-%EC%9D%98%EB%AF%B8\" aria-label=\"범위별 응답코드 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>범위별 응답코드 의미</h4>\n<ul>\n<li>100번대 : 요청이 들어왔을 때 정보적인 성격을 띠는 응답을 돌려준다.</li>\n<li>200번대 : 요청이 들어왔을 때 요청의 성격에 따라 '성공' 응답을 돌려준다.</li>\n<li>300번대 : 클라이언트의 요청을 수행하기 위해 부가적인 액션을 취해야한다는 응답을 돌려준다. 보통 요청을 리다이렉트(우회)할 때 사용한다.</li>\n<li>400번대 : 클라이언트에 의해 요청이 실패했을 때의 응답을 돌려준다.</li>\n<li>500번대 : 서버가 정당한 요청을 수행하지 못했을 때의 응답을 돌려준다.</li>\n</ul>\n<br>\n<h4 id=\"api-업데이트-시-기억해두면-좋을-응답코드\" style=\"position:relative;\"><a href=\"#api-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%8B%9C-%EA%B8%B0%EC%96%B5%ED%95%B4%EB%91%90%EB%A9%B4-%EC%A2%8B%EC%9D%84-%EC%9D%91%EB%8B%B5%EC%BD%94%EB%93%9C\" aria-label=\"api 업데이트 시 기억해두면 좋을 응답코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>API 업데이트 시 기억해두면 좋을 응답코드</h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">HTTP 상태코드</th>\n<th align=\"center\">성공/실패</th>\n<th align=\"center\">의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">410 GONE</td>\n<td align=\"center\">실패</td>\n<td align=\"center\">모든 통신메서드 - 더이상 제공되지 않는 메서드로 호출하여 새 버전의 API를 제공하기 위해 기존 API 서비스를 중지할 때 이용된다. 예를 들어 모바일 앱의 경우에는 해당 결과에 대해 사용자에게 어플 업그레이드를 요청하는 방법을 사용한다.</td>\n</tr>\n</tbody>\n</table>\n<br>\n<h4 id=\"http-응답코드-code-classlanguage-text200code과-code-classlanguage-text202code의-차이에-대하여\" style=\"position:relative;\"><a href=\"#http-%EC%9D%91%EB%8B%B5%EC%BD%94%EB%93%9C-code-classlanguage-text200code%EA%B3%BC-code-classlanguage-text202code%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\" aria-label=\"http 응답코드 code classlanguage text200code과 code classlanguage text202code의 차이에 대하여 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 응답코드 <code class=\"language-text\">200</code>과 <code class=\"language-text\">202</code>의 차이에 대하여</h4>\n<p>HTTP 응답코드는 서버에서 브라우저의 요청을 받아 응답을 반환하며 보내주는 상태를 알려준다. 그런데 최근 성공코드에 해당하는 <code class=\"language-text\">200</code>코드와 <code class=\"language-text\">202</code>코드에 대한 차이를 설명하라는 질문을 받고 당황한 기억이 있다. 프로젝트 도중 <code class=\"language-text\">202</code> 코드를 사용한 적이 있었는데 의미를 제대로 알고 썼는지 알아보는 질문이었다. 나중에 책을 찾아보고 <code class=\"language-text\">자주쓰이는 200</code> 통신과 <code class=\"language-text\">거의 사용하지 않는 202</code> 응답 코드의 차이를 알아보았다.</p>\n<p><code class=\"language-text\">200 OK</code>의 의미는 HTTP 요청이 성공했을 때 가장 많이 사용하는 응답코드이다. 요청 메서드가 <code class=\"language-text\">GET</code>일 때는 응답에 <code class=\"language-text\">요청된 자원</code>을 포함한다. 요청 메서드가 <code class=\"language-text\">POST</code>일 때는 응답에 액션의 결과를 포함한다.</p>\n<p>그렇다면 자주 쓰지 않는 <code class=\"language-text\">202 Accepted</code>는 어떤 의미일까? <code class=\"language-text\">200</code>과 마찬가지로 성공적인 응답코드이기는 하지만 요청에 대한 응답이 돌아오는 것과 상관없이 성공 코드를 먼저 출력해버린다. 따라서 요청에 대한 응답이 맞는지 체크하는 과정을 생략하고 무조건 성공 메세지를 보내게 되는 것이다.</p>\n<br>\n<p>해당 포스트는 <code class=\"language-text\">Two Scoops of Django</code> 도서의 16장 <code class=\"language-text\">REST API 구현하기 &lt;2부&gt;</code>로 계속됩니다. 2부에서는 REST API를 효율적으로 설계하는 방법들에 대해 소개합니다.</p>\n<br>\n<h3 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h3>\n<ul>\n<li>도서 Two Scoops of Django p.187 ~</li>\n<li><a href=\"http://restcookbook.com/HTTP%20Methods/patch/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">PATCH 메서드와 멱등성</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HTTP 응답코드 참고</a></li>\n</ul>\n<br>","excerpt":"(Representational State Transfer)는 기존의 HTTP 통신 프로토콜을 제대로 활용하기 위해 만들어진 규칙이다. 또한 인터넷은 더이상 형식에만 국한되지 않고 , , , 등의 여러 형식을 지원하고 있다. 이에 따라 다양한 환경과…","tableOfContents":"<ul>\n<li><a href=\"/2scoops-16-RESTAPI_01/#restful%ED%95%98%EB%8B%A4\">RESTful하다?</a></li>\n<li><a href=\"/2scoops-16-RESTAPI_01/#%ED%8C%A8%ED%82%A4%EC%A7%80-api%EB%A5%BC-%EC%A0%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%93%A4\">패키지 API를 제작하기 위한 패키지들</a></li>\n<li><a href=\"/2scoops-16-RESTAPI_01/#http-%EB%A9%94%EC%84%9C%EB%93%9C\">HTTP 메서드</a></li>\n<li><a href=\"/2scoops-16-RESTAPI_01/#http-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C\">HTTP 상태코드</a></li>\n<li><a href=\"/2scoops-16-RESTAPI_01/#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></li>\n</ul>","fields":{"slug":"/2scoops-16-RESTAPI_01/"},"frontmatter":{"title":"BookReview > Two Scoops of Django _ 16장. REST API 구현하기 <1부>","date":"Aug 30, 2017","tags":["book review","Django","REST api","HTTP"],"keywords":["Development Note","bbrubi"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/2scoops-16-RESTAPI_01/","series":[{"slug":"/2scoops-16-RESTAPI_01/","title":"BookReview > Two Scoops of Django _ 16장. REST API 구현하기 <1부>","num":1},{"slug":"/2scoops-16-RESTAPI_02/","title":"BookReview > Two Scoops of Django _ 16장. REST API 구현하기 <2부>","num":2}],"lastmod":"2017-08-30"}},"staticQueryHashes":["2027115977","694178885"]}